#!/bin/sh
# Unified entry point for PX4 simulation testing

set -eu

SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
REPO_ROOT=$(CDPATH= cd -- "$SCRIPT_DIR/.." && pwd)
PX4_DIR="$REPO_ROOT/px4"
PX4_BUILD_DIR="$PX4_DIR/build/px4_sitl_default"
QGC_DIR="$REPO_ROOT/qgroundcontrol"
QGC_BUILD_DIR="$REPO_ROOT/build/qgc-simtest"
QGC_ARTIFACT_DIR="$REPO_ROOT/artifacts/qgc"
MANIFEST_PATH="$REPO_ROOT/tools/environment_manifest.json"
QGC_STUB_HELPER="$SCRIPT_DIR/qgc_virtual_px4.py"

qgc_install_dir() {
  printf '%s\n' "${SIMTEST_QGC_INSTALL_DIR:-$QGC_BUILD_DIR/AppDir/usr}"
}

qgc_binary_path() {
  local install_root
  install_root=$(qgc_install_dir)
  printf '%s/bin/QGroundControl' "$install_root"
}

resolve_absolute_path() {
  python3 - "$1" <<'PY'
from pathlib import Path
import sys
print(Path(sys.argv[1]).expanduser().resolve())
PY
}

print_usage() {
  cat <<'USAGE'
Usage: simtest [build|run|collect|all|qgc|--help]
  build     Build PX4, models, dependencies
  run       Run the Gazebo simulation
  collect   Fetch artifacts (logs, flight results)
  all       Execute build + run + collect
  qgc       QGroundControl build/test helpers
USAGE
}

log() {
  printf '[simtest] %s\n' "$1"
}

qgc_usage() {
  cat <<'USAGE'
Usage: simtest qgc [build|test|stub|collect|all|--help]
  build     Configure and build QGroundControl with tests enabled
  test      Run ctest suite headlessly (xvfb when available)
  stub      Launch QGC simple boot test and exercise virtual PX4 handshake
  autoplan  Execute a mission file through QGroundControl headlessly
  collect   List QGC-specific artifacts
  all       build + test + stub + autoplan + collect in sequence
USAGE
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    log "error: $1 not found, please install with apt"
    exit 1
  fi
}

cleanup_sim_processes() {
  pkill -f "$PX4_BUILD_DIR/bin/px4" >/dev/null 2>&1 || true
  pkill -f "gz sim" >/dev/null 2>&1 || true
  pkill -f "cmake --build .* gz_" >/dev/null 2>&1 || true
}

jobs_count() {
  if command -v nproc >/dev/null 2>&1; then
    nproc
  else
    getconf _NPROCESSORS_ONLN 2>/dev/null || echo 1
  fi
}

resolve_qt_root() {
  if [ -n "${QT_ROOT_DIR:-}" ]; then
    printf '%s\n' "$QT_ROOT_DIR"
    return 0
  fi

  if [ ! -f "$MANIFEST_PATH" ]; then
    return 1
  fi

  python3 - "$MANIFEST_PATH" <<'PY'
import json
import os
import sys
from pathlib import Path

manifest_path = Path(sys.argv[1])
data = json.load(manifest_path.open('r', encoding='utf-8'))
qt = data.get('qt', {})
version = qt.get('version')
arch = qt.get('arch', 'gcc_64')
install_dir = Path(os.path.expanduser(qt.get('install_dir', '~/Qt')))
if not version:
    raise SystemExit(1)
print(install_dir.resolve() / version / arch)
PY
}

qgc_configure() {
  if [ ! -d "$QGC_DIR" ]; then
    log "error: QGroundControl directory not found at $QGC_DIR/"
    exit 1
  fi

  require_cmd python3
  require_cmd ninja

  if ! qt_root=$(resolve_qt_root); then
    log "error: unable to resolve Qt root from manifest"
    exit 1
  fi

  QT_ROOT_DIR=${QT_ROOT_DIR:-$qt_root}
  qt_cmake="$QT_ROOT_DIR/bin/qt-cmake"
  if [ ! -x "$qt_cmake" ]; then
    log "error: qt-cmake not found at $qt_cmake"
    exit 1
  fi

  mkdir -p "$QGC_BUILD_DIR"

  log "Configuring QGroundControl (Debug, tests enabled)"
  "$qt_cmake" \
    -S "$QGC_DIR" \
    -B "$QGC_BUILD_DIR" \
    -G Ninja \
    -DCMAKE_BUILD_TYPE="${QGC_BUILD_TYPE:-Debug}" \
    -DQGC_BUILD_TESTING=ON \
    -DQGC_STABLE_BUILD=OFF
}

qgc_build_target() {
  target=$1
  require_cmd cmake
  jobs=$(jobs_count)
  if [ -z "$jobs" ] || [ "$jobs" -lt 1 ]; then
    jobs=1
  fi

  log "Building QGroundControl target '$target' with $jobs parallel jobs"
  if [ "$target" = "package" ]; then
    if ! APPIMAGE_EXTRACT_AND_RUN=1 LINUXDEPLOY_NO_FUSE=1 cmake --build "$QGC_BUILD_DIR" --target "$target" --parallel "$jobs"; then
      log "error: cmake --build failed for target $target"
      exit 1
    fi
  else
    if ! cmake --build "$QGC_BUILD_DIR" --target "$target" --parallel "$jobs"; then
      log "error: cmake --build failed for target $target"
      exit 1
    fi
  fi
}

qgc_run_build() {
  qgc_configure
  qgc_build_target QGroundControl
  local install_root
  install_root=$(qgc_install_dir)
  log "Installing QGroundControl to $install_root"
  if [ -d "$install_root" ]; then
    log "Removing existing contents at $install_root"
    rm -rf "$install_root"
  fi
  mkdir -p "$install_root"
  mkdir -p "$REPO_ROOT/AppDir"
  rm -rf "$REPO_ROOT/AppDir/usr"
  ln -sfn "$install_root" "$REPO_ROOT/AppDir/usr"
  rm -f "$REPO_ROOT/AppRun"
  ln -sfn "$QGC_BUILD_DIR/AppRun" "$REPO_ROOT/AppRun"
  if ! APPIMAGE_EXTRACT_AND_RUN=1 LINUXDEPLOY_NO_FUSE=1 cmake --install "$QGC_BUILD_DIR" --prefix "$install_root"; then
    log "error: cmake --install failed"
    exit 1
  fi
  local binary
  binary=$(qgc_binary_path)
  if [ ! -x "$binary" ]; then
    log "error: installed QGroundControl binary missing at $binary"
    exit 1
  fi
}

qgc_run_test() {
  local binary
  binary=$(qgc_binary_path)

  if [ ! -x "$binary" ]; then
    log "Installed QGroundControl binary missing, running build first"
    qgc_run_build
    binary=$(qgc_binary_path)
  fi

  require_cmd ctest

  jobs=$(jobs_count)
  if [ -z "$jobs" ] || [ "$jobs" -lt 1 ]; then
    jobs=1
  fi

  mkdir -p "$QGC_ARTIFACT_DIR"

  log "Running QGroundControl ctest suite against installed binary"
  if command -v xvfb-run >/dev/null 2>&1; then
    xvfb-run -a ctest --test-dir "$QGC_BUILD_DIR" --output-on-failure -j "$jobs"
  else
    QT_QPA_PLATFORM=${QT_QPA_PLATFORM:-offscreen} ctest --test-dir "$QGC_BUILD_DIR" --output-on-failure -j "$jobs"
  fi

  log "Running QGroundControl installed unittest harness"
  if command -v xvfb-run >/dev/null 2>&1; then
    if ! xvfb-run -a "$binary" --unittest >"$QGC_ARTIFACT_DIR/unittest.log" 2>&1; then
      log "error: QGroundControl --unittest failed"
      exit 1
    fi
  else
    if ! QT_QPA_PLATFORM=${QT_QPA_PLATFORM:-offscreen} "$binary" --unittest >"$QGC_ARTIFACT_DIR/unittest.log" 2>&1; then
      log "error: QGroundControl --unittest failed"
      exit 1
    fi
  fi
}

qgc_run_stub() {
  local binary
  binary=$(qgc_binary_path)

  if [ ! -x "$binary" ]; then
    log "Installed QGroundControl binary missing, running build first"
    qgc_run_build
    binary=$(qgc_binary_path)
  fi

  if [ ! -f "$QGC_STUB_HELPER" ]; then
    log "error: stub helper missing at $QGC_STUB_HELPER"
    exit 1
  fi

  mkdir -p "$QGC_ARTIFACT_DIR"

  qgc_log="$QGC_ARTIFACT_DIR/simple_boot.log"
  stub_log="$QGC_ARTIFACT_DIR/virtual_px4.log"
  : >"$qgc_log"
  : >"$stub_log"

  duration=${SIMTEST_QGC_STUB_DURATION:-25}

  log "Starting QGroundControl headless session"
  if command -v xvfb-run >/dev/null 2>&1; then
    xvfb-run -a "$binary" --log-output --allow-multiple >"$qgc_log" 2>&1 &
  else
    QT_QPA_PLATFORM=${QT_QPA_PLATFORM:-offscreen} "$binary" --log-output --allow-multiple >"$qgc_log" 2>&1 &
  fi
  qgc_pid=$!

  # Allow QGC to finish startup before the stub pushes telemetry.
  sleep 4

  stub_args=""
  if [ "${SIMTEST_QGC_SKIP_PARAM_CHECK:-0}" = "1" ]; then
    stub_args="--skip-param-check"
  fi
  if [ "${SIMTEST_QGC_SKIP_HEARTBEAT_CHECK:-0}" = "1" ]; then
    stub_args="$stub_args --skip-heartbeat-check"
  fi

  if python3 "$QGC_STUB_HELPER" --duration "$duration" --log-file "$stub_log" $stub_args; then
    log "Virtual PX4 stub completed"
  else
    status=$?
    log "error: virtual PX4 stub failed (exit $status)"
    kill "$qgc_pid" >/dev/null 2>&1 || true
    wait "$qgc_pid" >/dev/null 2>&1 || true
    exit $status
  fi

  kill "$qgc_pid" >/dev/null 2>&1 || true
  wait "$qgc_pid" >/dev/null 2>&1 || true
}

qgc_run_autoplan() {
  local binary
  binary=$(qgc_binary_path)

  if [ ! -x "$binary" ]; then
    log "Installed QGroundControl binary missing, running build first"
    qgc_run_build
    binary=$(qgc_binary_path)
  fi

  require_cmd python3
  require_cmd timeout

  local plan_input
  plan_input=${SIMTEST_QGC_PLAN:-$REPO_ROOT/tests/qgc_plans/takeoff_land.plan}
  local plan_path
  plan_path=$(resolve_absolute_path "$plan_input")

  if [ ! -f "$plan_path" ]; then
    log "error: mission plan not found at $plan_path"
    exit 1
  fi

  mkdir -p "$QGC_ARTIFACT_DIR"

  local autoplan_log
  autoplan_log="$QGC_ARTIFACT_DIR/auto_plan.log"
  : >"$autoplan_log"

  local autoplan_timeout
  autoplan_timeout=${SIMTEST_QGC_PLAN_TIMEOUT:-180}

  set -- --log-output --allow-multiple --auto-fly-plan "$plan_path"
  if [ -n "${SIMTEST_QGC_EXTRA_ARGS:-}" ]; then
    for word in $SIMTEST_QGC_EXTRA_ARGS; do
      set -- "$@" "$word"
    done
  fi

  log "Running QGroundControl headless mission for $plan_path"
  if command -v xvfb-run >/dev/null 2>&1; then
    if ! timeout --foreground "$autoplan_timeout" xvfb-run -a "$binary" "$@" >"$autoplan_log" 2>&1; then
      log "error: QGroundControl headless mission failed"
      exit 1
    fi
  else
    if ! QT_QPA_PLATFORM=${QT_QPA_PLATFORM:-offscreen} timeout --foreground "$autoplan_timeout" "$binary" "$@" >"$autoplan_log" 2>&1; then
      log "error: QGroundControl headless mission failed"
      exit 1
    fi
  fi
}

qgc_collect() {
  if [ ! -d "$QGC_ARTIFACT_DIR" ]; then
    log "warning: QGC artifact directory not found at $QGC_ARTIFACT_DIR/"
    return
  fi

  log "QGC artifacts located in $QGC_ARTIFACT_DIR/"
  if ls -A "$QGC_ARTIFACT_DIR" >/dev/null 2>&1; then
    ls "$QGC_ARTIFACT_DIR" | sed 's/^/[simtest]   /'
  else
    log "  (empty)"
  fi
}

qgc_run_all() {
  qgc_run_build
  qgc_run_test
  qgc_run_stub
  qgc_run_autoplan
  qgc_collect
}

dispatch_qgc() {
  sub=${1-}

  case "$sub" in
    build)
      qgc_run_build
      ;;
    test)
      qgc_run_test
      ;;
    stub)
      qgc_run_stub
      ;;
    autoplan)
      qgc_run_autoplan
      ;;
    collect)
      qgc_collect
      ;;
    all)
      qgc_run_all
      ;;
    -h|--help|"")
      qgc_usage
      ;;
    *)
      printf '[simtest] error: unknown qgc subcommand %s\n' "$sub" 1>&2
      qgc_usage 1>&2
      exit 1
      ;;
  esac
}

run_build() {
  log "PX4 directory: $PX4_DIR/"

  if [ ! -d "$PX4_DIR" ]; then
    log "error: PX4 directory not found at $PX4_DIR/"
    exit 1
  fi

  require_cmd cmake
  require_cmd make

  jobs=$(jobs_count)
  if [ -z "$jobs" ] || [ "$jobs" -lt 1 ]; then
    jobs=1
  fi

  log "Building px4_sitl_default with $jobs parallel jobs..."
  if ! (cd "$PX4_DIR" && make -j"$jobs" px4_sitl_default); then
    log "error: make px4_sitl_default failed, check logs"
    exit 1
  fi

  if [ ! -x "$PX4_BUILD_DIR/bin/px4" ]; then
    log "error: px4 binary missing after build"
    exit 1
  fi

  log "Build complete"
}

run_run() {
  if [ ! -d "$PX4_DIR" ]; then
    log "error: PX4 directory not found at $PX4_DIR/"
    exit 1
  fi

  require_cmd timeout
  require_cmd gz
  require_cmd make
  require_cmd python3

  SIM_DURATION=${SIM_DURATION:-45}
  SIM_TIMEOUT_SIGNAL=${SIM_TIMEOUT_SIGNAL:-SIGINT}
  SIM_KILL_AFTER=${SIM_KILL_AFTER:-30}

  SCENARIO_NAME=${SIMTEST_SCENARIO:-takeoff_land}
  SCENARIO_SCRIPT=""
  SCENARIO_PID=""
  SCENARIO_EXIT=0
  SCENARIO_LOG=""
  SCENARIO_SUMMARY=""
  SCENARIO_TAIL_PID=""

  ARTIFACT_DIR=${SIMTEST_ARTIFACT_DIR:-$REPO_ROOT/artifacts}
  mkdir -p "$ARTIFACT_DIR"

  SIM_MODEL_RAW=${PX4_SIM_MODEL:-x500}
  case "$SIM_MODEL_RAW" in
    gz_*) MODEL_TARGET="$SIM_MODEL_RAW" ;;
    *) MODEL_TARGET="gz_${SIM_MODEL_RAW}" ;;
  esac

  if [ "$SCENARIO_NAME" != "none" ]; then
    CANDIDATE="$REPO_ROOT/tests/scenarios/${SCENARIO_NAME}.py"
    if [ -f "$CANDIDATE" ]; then
      SCENARIO_SCRIPT="$CANDIDATE"
    else
      log "warning: scenario script $SCENARIO_NAME not found at $CANDIDATE, skipping"
    fi
  fi

  if [ ! -x "$PX4_BUILD_DIR/bin/px4" ]; then
    log "PX4 build not found, running build first"
    run_build
  fi

  cleanup_sim_processes

  HEARTBEAT_HELPER="$SCRIPT_DIR/mavlink_heartbeat.py"
  HEARTBEAT_PID=""

  cleanup_trap() {
    if [ -n "$HEARTBEAT_PID" ]; then
      kill "$HEARTBEAT_PID" >/dev/null 2>&1 || true
      wait "$HEARTBEAT_PID" >/dev/null 2>&1 || true
      HEARTBEAT_PID=""
    fi
    if [ -n "$SCENARIO_PID" ]; then
      if wait "$SCENARIO_PID"; then
        SCENARIO_EXIT=0
      else
        SCENARIO_EXIT=$?
      fi
      SCENARIO_PID=""
    fi
    if [ -n "$SCENARIO_TAIL_PID" ]; then
      kill "$SCENARIO_TAIL_PID" >/dev/null 2>&1 || true
      wait "$SCENARIO_TAIL_PID" >/dev/null 2>&1 || true
      SCENARIO_TAIL_PID=""
    fi
    cleanup_sim_processes
  }

  trap cleanup_trap INT TERM EXIT

  if [ -f "$HEARTBEAT_HELPER" ] && [ -z "$SCENARIO_SCRIPT" ]; then
    HB_DURATION=$((SIM_DURATION + SIM_KILL_AFTER))
    log "Starting MAVLink heartbeat helper on UDP 14550"
    if python3 "$HEARTBEAT_HELPER" --duration "$HB_DURATION" --rate 2.0 >/dev/null 2>&1 & then
      HEARTBEAT_PID=$!
    else
      log "warning: failed to launch heartbeat helper"
    fi
  fi

  if [ -n "$SCENARIO_SCRIPT" ]; then
    SCENARIO_DELAY=${SIMTEST_SCENARIO_DELAY:-8}
    SCENARIO_LOG="$ARTIFACT_DIR/${SCENARIO_NAME}.log"
    SCENARIO_SUMMARY="$ARTIFACT_DIR/${SCENARIO_NAME}_summary.json"
    : >"$SCENARIO_LOG"
    : >"$SCENARIO_SUMMARY"
    if command -v tail >/dev/null 2>&1; then
      tail -n0 -F "$SCENARIO_LOG" &
      SCENARIO_TAIL_PID=$!
    fi
    log "Starting scenario $SCENARIO_NAME after ${SCENARIO_DELAY}s delay"
    (
      sleep "$SCENARIO_DELAY"
      SIMTEST_SCENARIO_RESULT="$SCENARIO_SUMMARY" python3 -u "$SCENARIO_SCRIPT"
    ) >>"$SCENARIO_LOG" 2>&1 &
    SCENARIO_PID=$!
  fi

  PX4_GZ_MODEL_PATH="$REPO_ROOT/px4-gazebo-models:$PX4_DIR/Tools/simulation/gz/models"
  GZ_SIM_RESOURCE_PATH="$PX4_GZ_MODEL_PATH:$PX4_DIR/Tools/simulation/gz/worlds"

  export PX4_GZ_MODEL_PATH
  export GZ_SIM_RESOURCE_PATH
  export HEADLESS=1
  export PX4_SIM_MODEL="$MODEL_TARGET"

  log "Starting headless Gazebo Harmonic (model=$MODEL_TARGET, run window=${SIM_DURATION}s)..."

  if timeout --foreground --signal="$SIM_TIMEOUT_SIGNAL" --kill-after="$SIM_KILL_AFTER" "$SIM_DURATION" sh -c "cd '$PX4_DIR' && make px4_sitl '$MODEL_TARGET'"; then
    log "Simulation completed cleanly"
  else
    status=$?
    if [ "$status" -eq 124 ] || [ "$status" -eq 137 ] || [ "$status" -eq 143 ]; then
      log "Simulation stopped after ${SIM_DURATION}s window"
    else
      log "error: simulation failed (exit $status), check logs"
      exit 1
    fi
  fi

  trap - INT TERM EXIT
  cleanup_trap

  if [ "$SCENARIO_EXIT" -ne 0 ]; then
    log "error: scenario exited with status $SCENARIO_EXIT"
    exit 1
  fi

  if [ -n "$SCENARIO_SUMMARY" ] && [ -f "$SCENARIO_SUMMARY" ]; then
    log "Scenario summary: $(cat "$SCENARIO_SUMMARY")"
  fi

  latest_log=$(ls -1t "$PX4_DIR"/build/px4_sitl_default/rootfs/log/*/*.ulg "$PX4_DIR"/log/*/*.ulg 2>/dev/null | head -n1 || true)
  if [ -n "$latest_log" ] && [ -f "$latest_log" ]; then
    dest="$ARTIFACT_DIR/$(basename "$latest_log")"
    if cp "$latest_log" "$dest" 2>/dev/null; then
      log "PX4 log archived to $dest"
    else
      log "warning: unable to copy PX4 log from $latest_log"
    fi
  fi
}

run_collect() {
  ARTIFACT_DIR=${SIMTEST_ARTIFACT_DIR:-$REPO_ROOT/artifacts}

  if [ ! -d "$ARTIFACT_DIR" ]; then
    log "warning: artifact directory not found at $ARTIFACT_DIR/"
    return
  fi

  log "Artifacts located in $ARTIFACT_DIR/"
  if ls -A "$ARTIFACT_DIR" >/dev/null 2>&1; then
    ls "$ARTIFACT_DIR" | sed 's/^/[simtest]   /'
  else
    log "  (empty)"
  fi
}

run_all() {
  run_build
  run_run
  run_collect
}

main() {
  cmd=${1-}

  case "$cmd" in
    build)
      run_build
      ;;
    run)
      run_run
      ;;
    collect)
      run_collect
      ;;
    all)
      run_all
      ;;
    qgc)
      shift || true
      dispatch_qgc "$@"
      ;;
    -h|--help)
      print_usage
      ;;
    "")
      print_usage
      exit 1
      ;;
    *)
      printf '[simtest] error: unknown command %s\n' "$cmd" 1>&2
      print_usage 1>&2
      exit 1
      ;;
  esac
}

main "$@"
